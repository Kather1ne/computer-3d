/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useContext, useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { useGesture } from "react-use-gesture";
import { RangeContext } from "../context/range";
import { useSpring, animated } from "@react-spring/three";
import {
  iconMaterial,
  rangeScaleMaterial,
  rangeWrapperMaterial,
  scaleBaseMaterial,
  scaleCirclesMaterial,
  violetMaterial,
  whiteMaterial,
} from "../constants/materials";

const scale = 0.01;
const END_X = 65;
const START_X = -45;

const minScale = [1.3, 1.3, 1.3];
const maxScale = [1.4, 1.4, 1.4];

const defaultButtonStyles = {
  scale: minScale,
  config: { tension: 250, friction: 20 },
};

export function Range() {
  const { nodes } = useGLTF("./models/helpers.gltf");

  const rangeRef = useRef();
  const buttonRef = useRef();
  const { changeRange } = useContext(RangeContext);

  const [isHovering, setIsHovering] = useState(false);
  const [buttonSpring, setButtonSpring] = useSpring(() => defaultButtonStyles);

  const bind = useGesture({
    onDrag: ({ delta: [x] }) => {
      const newPosition = buttonRef.current.position.x + x;

      if (newPosition >= START_X && newPosition <= END_X && isHovering) {
        buttonRef.current.position.set(
          newPosition,
          buttonRef.current.position.y,
          buttonRef.current.position.z
        );

        if (newPosition < 0) {
          changeRange(newPosition / Math.abs(START_X));
        } else {
          changeRange(newPosition / Math.abs(END_X));
        }
      }
    },

    onHover: ({ hovering }) => {
      setButtonSpring({ scale: hovering ? maxScale : minScale });
    },
  });

  return (
    <group dispose={null} position={[0, 4, 1]}>
      <group scale={scale}>
        <group position={[251.335, 0, 0]}>
          <group position={[11.895, 26.313, 14.51]}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Ellipse_1.geometry}
              material={scaleCirclesMaterial}
              position={[-22.532, -22.489, -1.51]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Ellipse_1.geometry}
              material={scaleCirclesMaterial}
              position={[22.532, -22.489, -1.51]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Ellipse_1.geometry}
              material={scaleCirclesMaterial}
              position={[22.532, 22.489, -1.51]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Ellipse_1.geometry}
              material={scaleCirclesMaterial}
              position={[-22.532, 22.489, -1.51]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Shape.geometry}
              material={scaleBaseMaterial}
              position={[-22.567, 22.449, -0.51]}
              scale={[1, 1, 1.004]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Star.geometry}
              material={iconMaterial}
              position={[-0.424, -0.312, -2.51]}
              scale={[1, 1, 1.004]}
            />
          </group>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Rectangle_1.geometry}
            position={[12.665, -26.349, 18]}
            material={rangeScaleMaterial}
          />
          <animated.mesh
            castShadow
            receiveShadow
            geometry={nodes.Ellipse_2.geometry}
            material={violetMaterial}
            position={[12.665, -26.349, 18]}
            ref={buttonRef}
            {...bind()}
            {...buttonSpring}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes["range-bg"].geometry}
            material={rangeWrapperMaterial}
            position={[12.665, -26.349, 15]}
            ref={rangeRef}
            onPointerOver={() => setIsHovering(true)}
            onPointerOut={() => setIsHovering(false)}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Rectangle_2.geometry}
            material={whiteMaterial}
            position={[11.471, 0, 3.5]}
          />
        </group>
      </group>
    </group>
  );
}
